---
// TypeScript support enabled
---
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Video Wallpaper Generator</title>
		<style>
			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}
		</style>
	</head>
	<body style="font-family: system-ui, sans-serif; background: #18181b; color: #fff; margin: 0;">
		<main style="max-width: 800px; margin: 3rem auto; padding: 2rem; background: #23232a; border-radius: 1rem; box-shadow: 0 2px 16px #0002;">
			<h1 style="font-size: 2.5rem; margin-bottom: 0.5em;">Video Wallpaper Generator</h1>
			<p style="font-size: 1.2rem; margin-bottom: 2em;">
				Transform your podcast or radio show audio into YouTube-ready video with evolving, ambient visuals and automated branding overlays.
			</p>
			
			<div id="workflow" style="margin-bottom: 2em;">
				<h3>Workflow:</h3>
				<ol>
					<li>Upload your audio file (WAV/MP3, â‰¤ 250 MB)</li>
					<li>Enter episode details (optional)</li>
					<li>Select a visual style preset</li>
					<li>Preview a 15-second sample</li>
					<li>Approve or regenerate</li>
					<li>Render and download your full video</li>
				</ol>
			</div>

			<div style="margin-bottom: 2em; padding: 1.5em; background: #1f1f23; border-radius: 0.5em; border: 1px solid #333;">
				<h3 style="margin-top: 0; color: #6366f1;">Quick Test Videos</h3>
				<p style="margin-bottom: 1em; color: #aaa;">
					Generate sample videos with different style presets to test the system.
				</p>
				<div style="display: flex; flex-wrap: wrap; gap: 1em; margin-bottom: 1em;">
					<button 
						id="testVideoFrenchNewWave"
						style="padding: 0.75em 1.5em; font-size: 1em; background: #6366f1; color: #fff; border: none; border-radius: 0.5em; cursor: pointer;"
					>
						ðŸŽ¬ French New Wave
					</button>
					<button 
						id="testVideoRetro"
						style="padding: 0.75em 1.5em; font-size: 1em; background: #8b5cf6; color: #fff; border: none; border-radius: 0.5em; cursor: pointer;"
					>
						ðŸŽ¬ '80s Retro Chromatic
					</button>
					<button 
						id="testVideoWineCountry"
						style="padding: 0.75em 1.5em; font-size: 1em; background: #d97706; color: #fff; border: none; border-radius: 0.5em; cursor: pointer;"
					>
						ðŸŽ¬ Wine-Country Dreamscape
					</button>
				</div>
				<span style="color: #aaa; font-size: 0.9em;">Each creates a 5-second sample with the selected style preset</span>
			</div>

			<!-- Live Preview Canvas -->
			<div id="livePreviewContainer" style="margin-bottom: 2em; background: #1f1f23; border-radius: 0.5em; overflow: hidden; border: 1px solid #333; display: none;">
				<div style="padding: 1em; text-align: center; color: #6366f1; font-weight: 500; border-bottom: 1px solid #333;">
					ðŸŽ¬ Live Preview
				</div>
				<canvas 
					id="livePreviewCanvas" 
					style="width: 100%; max-width: 100%; height: auto; display: block; background: #000;"
				></canvas>
			</div>

			<!-- Processing Status -->
			<div id="status" style="margin-bottom: 2em; display: none;">
				<h3>Processing Status:</h3>
				<div id="statusText" style="color: #10b981; font-weight: 500; margin-bottom: 0.5em;"></div>
				<div id="stageIndicator" style="color: #6366f1; font-size: 0.9em; margin-bottom: 1em;"></div>
				
				<div id="progress" style="margin-top: 1em;">
					<div style="background: #1f1f23; height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
						<div id="progressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); border-radius: 10px; transition: width 0.5s ease; position: relative;">
							<div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: white; font-size: 0.8em; font-weight: 500; text-shadow: 0 1px 2px rgba(0,0,0,0.5);"></div>
						</div>
					</div>
				</div>
				<div id="frameCountIndicator" style="margin-top: 0.5em; color: #aaa; font-size: 0.9em;"></div>
			</div>

			<form id="uploadForm" style="display: flex; flex-direction: column; gap: 1.5em;">
				<div>
					<label for="audioFile">
						<strong>Audio File</strong>
					</label>
					<input 
						type="file" 
						id="audioFile" 
						name="audio" 
						accept="audio/wav,audio/mp3" 
						style="margin-top: 0.5em; width: 100%;" 
						required
					/>
					<div id="fileInfo" style="margin-top: 0.5em; font-size: 0.9em; color: #aaa;"></div>
				</div>

				<div>
					<label for="title">
						<strong>Episode Title</strong>
					</label>
					<input 
						type="text" 
						id="title" 
						name="title" 
						placeholder="Enter episode title" 
						style="margin-top: 0.5em; width: 100%; padding: 0.5em;" 
					/>
				</div>

				<div>
					<label for="guest">
						<strong>Guest (Optional)</strong>
					</label>
					<input 
						type="text" 
						id="guest" 
						name="guest" 
						placeholder="Guest name" 
						style="margin-top: 0.5em; width: 100%; padding: 0.5em;" 
					/>
				</div>

				<div>
					<label for="sponsor">
						<strong>Sponsor (Optional)</strong>
					</label>
					<input 
						type="text" 
						id="sponsor" 
						name="sponsor" 
						placeholder="Sponsor name" 
						style="margin-top: 0.5em; width: 100%; padding: 0.5em;" 
					/>
				</div>

				<div>
					<label for="stylePreset">
						<strong>Style Preset</strong>
					</label>
					<select 
						id="stylePreset" 
						name="stylePreset" 
						style="margin-top: 0.5em; width: 100%; padding: 0.5em;"
					>
						<option value="French New Wave">French New Wave</option>
						<option value="'80s Retro Chromatic">'80s Retro Chromatic</option>
						<option value="Wine-Country Dreamscape">Wine-Country Dreamscape</option>
					</select>
				</div>

				<button 
					type="submit" 
					id="submitBtn"
					style="padding: 0.75em 2em; font-size: 1.1em; background: #6366f1; color: #fff; border: none; border-radius: 0.5em; cursor: pointer;"
				>
					Generate Video
				</button>
			</form>

			<div id="results" style="margin-top: 2em; display: none;">
				<h3>Results:</h3>
				<div id="videoInfo" style="background: #1f1f23; padding: 1em; border-radius: 0.5em; margin-bottom: 1em;"></div>
				
				<!-- Video Player -->
				<div id="videoPlayerContainer" style="margin-bottom: 1em; background: #1f1f23; border-radius: 0.5em; overflow: hidden; border: 1px solid #333;">
					<div id="videoLoadingIndicator" style="display: none; text-align: center; padding: 2em; color: #6366f1;">
						<div style="margin-bottom: 1em;">ðŸŽ¬ Loading video...</div>
						<div style="width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
					</div>
					<video 
						id="videoPlayer" 
						controls 
						style="width: 100%; max-width: 100%; height: auto; display: block; background: #000;"
						preload="metadata"
					>
						Your browser does not support the video tag.
					</video>
				</div>
				
				<div style="display: flex; gap: 1em;">
					<button id="downloadBtn" style="padding: 0.5em 1em; background: #10b981; color: #fff; border: none; border-radius: 0.5em; cursor: pointer;">
						Download Video
					</button>
					<button id="youtubeBtn" style="padding: 0.5em 1em; background: #ef4444; color: #fff; border: none; border-radius: 0.5em; cursor: pointer;">
						Upload to YouTube
					</button>
				</div>
			</div>

			<div style="margin-top: 2em; color: #aaa; font-size: 0.95em;">
				<p><em>Note: This is an MVP prototype. Video rendering and AI visuals are simulated for demonstration.</em></p>
			</div>
		</main>

		<script>
			console.log('SCRIPT LOADED');
			const form = document.getElementById('uploadForm') as HTMLFormElement;
			const fileInput = document.getElementById('audioFile') as HTMLInputElement;
			const fileInfo = document.getElementById('fileInfo') as HTMLDivElement;
			const status = document.getElementById('status') as HTMLDivElement;
			const statusText = document.getElementById('statusText') as HTMLDivElement;
			const stageIndicator = document.getElementById('stageIndicator') as HTMLDivElement;
			const progressBar = document.getElementById('progressBar') as HTMLDivElement;
			const results = document.getElementById('results') as HTMLDivElement;
			const videoInfo = document.getElementById('videoInfo') as HTMLDivElement;
			const downloadBtn = document.getElementById('downloadBtn') as HTMLButtonElement;
			const youtubeBtn = document.getElementById('youtubeBtn') as HTMLButtonElement;
			const frameCountIndicator = document.getElementById('frameCountIndicator') as HTMLDivElement;
			const testVideoFrenchNewWave = document.getElementById('testVideoFrenchNewWave') as HTMLButtonElement;
			const testVideoRetro = document.getElementById('testVideoRetro') as HTMLButtonElement;
			const testVideoWineCountry = document.getElementById('testVideoWineCountry') as HTMLButtonElement;
			const videoPlayer = document.getElementById('videoPlayer') as HTMLVideoElement;
			const videoLoadingIndicator = document.getElementById('videoLoadingIndicator') as HTMLDivElement;
			const livePreviewCanvas = document.getElementById('livePreviewCanvas') as HTMLCanvasElement;
			const livePreviewContainer = document.getElementById('livePreviewContainer') as HTMLDivElement;

			let currentVideoPath: string = '';
			let currentVideoUrl: string = '';
			let currentJobId: string = '';
			let cachedTestAudioFile: File | null = null;

			// Function to clear the test audio cache (useful when switching audio files)
			function clearTestAudioCache() {
				cachedTestAudioFile = null;
				console.log('Test audio cache cleared');
			}

			// Function to initialize the live preview canvas
			function initializeLivePreview() {
				if (livePreviewCanvas && livePreviewContainer) {
					// Show the preview container
					livePreviewContainer.style.display = 'block';
					
					// Set canvas size for proper display
					const containerWidth = livePreviewContainer.clientWidth - 40; // Account for padding
					const aspectRatio = 16 / 9;
					const displayHeight = containerWidth / aspectRatio;
					
					livePreviewCanvas.style.width = `${containerWidth}px`;
					livePreviewCanvas.style.height = `${displayHeight}px`;
					
					// Clear the canvas
					const ctx = livePreviewCanvas.getContext('2d');
					if (ctx) {
						ctx.fillStyle = '#000';
						ctx.fillRect(0, 0, livePreviewCanvas.width, livePreviewCanvas.height);
					}
				}
			}

			// Browser-based video generation
			class BrowserVideoGenerator {
				private canvas: HTMLCanvasElement;
				private ctx: CanvasRenderingContext2D;
				private audioContext: AudioContext | null = null;
				private audioData: Float32Array | null = null;
				private sampleRate: number = 44100;
				private previewCanvas: HTMLCanvasElement | null = null;
				private previewCtx: CanvasRenderingContext2D | null = null;

				constructor(previewCanvas?: HTMLCanvasElement) {
					this.canvas = document.createElement('canvas');
					this.canvas.width = 1920;
					this.canvas.height = 1080;
					this.ctx = this.canvas.getContext('2d')!;
					
					// Set up preview canvas if provided
					if (previewCanvas) {
						this.previewCanvas = previewCanvas;
						this.previewCanvas.width = 1920;
						this.previewCanvas.height = 1080;
						this.previewCtx = this.previewCanvas.getContext('2d')!;
					}
				}

				// Method to update the preview canvas with the current frame
				private updatePreview(): void {
					if (this.previewCtx && this.previewCanvas) {
						// Copy the current frame to the preview canvas
						this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
						this.previewCtx.drawImage(this.canvas, 0, 0, this.previewCanvas.width, this.previewCanvas.height);
					}
				}

				async analyzeAudio(audioFile: File): Promise<any> {
					console.log('Analyzing audio in browser...');
					
					// Create audio context
					this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
					
					// Resume audio context if suspended (required for autoplay policies)
					if (this.audioContext.state === 'suspended') {
						await this.audioContext.resume();
					}
					
					// Load audio file
					const arrayBuffer = await audioFile.arrayBuffer();
					const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
					
					// Extract audio data
					const channelData = audioBuffer.getChannelData(0);
					this.audioData = channelData;
					this.sampleRate = audioBuffer.sampleRate;
					
					// Calculate RMS values with more granular segments
					const fps = 30;
					const totalFrames = Math.floor(audioBuffer.duration * fps);
					const rmsValues = [];
					const vocalEnergy = [];
					const frequencies = [];
					
					// Create one RMS value per frame for better synchronization
					for (let frame = 0; frame < totalFrames; frame++) {
						const startTime = frame / fps;
						const endTime = (frame + 1) / fps;
						
						const startSample = Math.floor(startTime * this.sampleRate);
						const endSample = Math.floor(endTime * this.sampleRate);
						
						let sum = 0;
						let count = 0;
						
						for (let i = startSample; i < endSample && i < channelData.length; i++) {
							sum += channelData[i] * channelData[i];
							count++;
						}
						
						const rms = count > 0 ? Math.sqrt(sum / count) : 0.1;
						rmsValues.push(rms);
						vocalEnergy.push(Math.min(1, rms * 2));
						frequencies.push(150 + 100 * Math.sin(startTime * 2)); // Varying frequency
					}
					
					return {
						duration: audioBuffer.duration,
						rms: rmsValues,
						vocalEnergy: vocalEnergy,
						frequencies: frequencies,
						sampleRate: this.sampleRate,
						totalFrames: totalFrames
					};
				}

				generateFrame(time: number, audioAnalysis: any, stylePreset: string): void {
					const fps = 30;
					const frameIndex = Math.floor(time * fps);
					
					// Use frame-based audio analysis for better synchronization
					const rms = audioAnalysis.rms[frameIndex] || 0.1;
					
					// Clear canvas
					this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
					
					// Generate background based on style preset
					this.generateBackground(rms, stylePreset);
					
					// Generate visual elements based on style preset
					this.generateVisualElements(time, rms, stylePreset);
					
					// Update the preview canvas
					this.updatePreview();
				}

				private generateBackground(rms: number, stylePreset: string): void {
					if (stylePreset === 'French New Wave') {
						// French New Wave: Black and white with RMS-reactive contrast
						const brightness = rms > 0.15 ? (20 + rms * 60) : (10 + rms * 20);
						const color = `rgb(${brightness}%, ${brightness}%, ${brightness}%)`;
						this.ctx.fillStyle = color;
						this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
					} else if (stylePreset === "'80s Retro Chromatic") {
						// 80s Retro: Colorful gradient
						const hue = (Date.now() * 0.1) % 360;
						const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
						gradient.addColorStop(0, `hsl(${hue}, 80%, 60%)`);
						gradient.addColorStop(1, `hsl(${hue + 180}, 80%, 60%)`);
						this.ctx.fillStyle = gradient;
						this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
					} else {
						// Wine Country: Warm colors
						const gradient = this.ctx.createRadialGradient(
							this.canvas.width / 2, this.canvas.height / 2, 0,
							this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 2
						);
						gradient.addColorStop(0, '#DAA520');
						gradient.addColorStop(1, '#8B4513');
						this.ctx.fillStyle = gradient;
						this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
					}
				}

				private generateVisualElements(time: number, rms: number, stylePreset: string): void {
					if (stylePreset === 'French New Wave') {
						this.generateFrenchNewWaveElements(time, rms);
					} else if (stylePreset === "'80s Retro Chromatic") {
						this.generateRetroElements(time, rms);
					} else {
						this.generateWineCountryElements(time, rms);
					}
				}

				private generateFrenchNewWaveElements(time: number, rms: number): void {
					// Jump cut effect
					if (rms > 0.15) {
						// Flash effect
						this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
						this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
					}
					
					// Geometric shapes
					const numShapes = Math.floor(2 + rms * 4);
					for (let i = 0; i < numShapes; i++) {
						const x = this.canvas.width * 0.2 + (i * this.canvas.width * 0.3);
						const y = this.canvas.height * 0.4 + (i * this.canvas.height * 0.2);
						const size = 20 + rms * 60;
						
						this.ctx.fillStyle = rms > 0.2 ? '#ffffff' : '#000000';
						this.ctx.strokeStyle = rms > 0.2 ? '#000000' : '#ffffff';
						this.ctx.lineWidth = 1 + rms * 2;
						
						if (i % 2 === 0) {
							// Triangle
							this.ctx.beginPath();
							this.ctx.moveTo(x, y - size);
							this.ctx.lineTo(x - size, y + size);
							this.ctx.lineTo(x + size, y + size);
							this.ctx.closePath();
							this.ctx.fill();
							this.ctx.stroke();
						} else {
							// Rectangle
							this.ctx.fillRect(x - size, y - size, size * 2, size * 2);
							this.ctx.strokeRect(x - size, y - size, size * 2, size * 2);
						}
					}
					
					// Lines
					const numLines = Math.floor(2 + rms * 6);
					for (let i = 0; i < numLines; i++) {
						const y1 = this.canvas.height * 0.2 + (i * this.canvas.height * 0.25);
						const y2 = y1 + Math.sin(time + i) * (50 + rms * 150);
						const strokeWidth = 1 + rms * 5;
						
						this.ctx.strokeStyle = rms > 0.18 ? '#ffffff' : '#000000';
						this.ctx.lineWidth = strokeWidth;
						this.ctx.beginPath();
						this.ctx.moveTo(0, y1);
						this.ctx.lineTo(this.canvas.width, y2);
						this.ctx.stroke();
					}
				}

				private generateRetroElements(time: number, rms: number): void {
					// Grid lines
					const gridSize = 50 + rms * 100;
					this.ctx.strokeStyle = '#ff00ff';
					this.ctx.lineWidth = 1 + rms * 2;
					
					for (let x = 0; x < this.canvas.width; x += gridSize) {
						this.ctx.beginPath();
						this.ctx.moveTo(x, 0);
						this.ctx.lineTo(x, this.canvas.height);
						this.ctx.stroke();
					}
					
					for (let y = 0; y < this.canvas.height; y += gridSize) {
						this.ctx.beginPath();
						this.ctx.moveTo(0, y);
						this.ctx.lineTo(this.canvas.width, y);
						this.ctx.stroke();
					}
					
					// Circles
					const numCircles = Math.floor(3 + rms * 5);
					for (let i = 0; i < numCircles; i++) {
						const x = this.canvas.width * 0.2 + (i * this.canvas.width * 0.2);
						const y = this.canvas.height * 0.5 + Math.sin(time + i) * 50;
						const radius = 20 + rms * 40;
						
						this.ctx.fillStyle = `hsl(${i * 60}, 80%, 60%)`;
						this.ctx.beginPath();
						this.ctx.arc(x, y, radius, 0, Math.PI * 2);
						this.ctx.fill();
					}
				}

				private generateWineCountryElements(time: number, rms: number): void {
					// Vineyard-like elements
					const numVines = Math.floor(5 + rms * 10);
					for (let i = 0; i < numVines; i++) {
						const x = this.canvas.width * 0.1 + (i * this.canvas.width * 0.15);
						const startY = this.canvas.height * 0.8;
						const endY = this.canvas.height * 0.2;
						
						this.ctx.strokeStyle = '#8B4513';
						this.ctx.lineWidth = 2 + rms * 3;
						this.ctx.beginPath();
						this.ctx.moveTo(x, startY);
						
						// Curved vine
						for (let y = startY; y > endY; y -= 20) {
							const curveX = x + Math.sin(time + i + y * 0.01) * (20 + rms * 50);
							this.ctx.lineTo(curveX, y);
						}
						this.ctx.stroke();
						
						// Leaves
						if (rms > 0.1) {
							this.ctx.fillStyle = '#228B22';
							this.ctx.beginPath();
							this.ctx.ellipse(x, endY + 50, 10 + rms * 20, 5 + rms * 10, 0, 0, Math.PI * 2);
							this.ctx.fill();
						}
					}
				}

				async generateVideo(audioAnalysis: any, stylePreset: string, onProgress?: (frame: number, total: number) => void, audioFile?: File): Promise<Blob> {
					console.log('Generating video in browser...');
					
					const fps = 30;
					const totalFrames = Math.floor(audioAnalysis.duration * fps);
					const chunks: Blob[] = [];
					
					// Create MediaRecorder with both video and audio
					const videoStream = this.canvas.captureStream(fps);
					
					// If we have an audio file, add it to the stream
					if (audioFile && this.audioContext && this.audioContext.state === 'running') {
						try {
							// Create audio element and load the audio file
							const audioElement = document.createElement('audio');
							audioElement.src = URL.createObjectURL(audioFile);
							audioElement.crossOrigin = 'anonymous';
							
							// Create audio context and connect audio element
							const audioDestination = this.audioContext.createMediaStreamDestination();
							const audioSource = this.audioContext.createMediaElementSource(audioElement);
							audioSource.connect(audioDestination);
							audioSource.connect(this.audioContext.destination); // Also connect to speakers for monitoring
							
							// Combine video and audio streams
							const combinedStream = new MediaStream([
								...videoStream.getVideoTracks(),
								...audioDestination.stream.getAudioTracks()
							]);
							
							const mediaRecorder = new MediaRecorder(combinedStream, {
								mimeType: 'video/webm;codecs=vp9,opus'
							});
							
							return new Promise((resolve, reject) => {
								mediaRecorder.ondataavailable = (event) => {
									if (event.data.size > 0) {
										chunks.push(event.data);
									}
								};
								
								mediaRecorder.onstop = () => {
									const blob = new Blob(chunks, { type: 'video/webm' });
									resolve(blob);
								};
								
								mediaRecorder.onerror = reject;
								
								// Start recording and playing audio
								mediaRecorder.start();
								audioElement.play();
								
								// Generate frames
								let frameIndex = 0;
								const frameInterval = 1000 / fps;
								
								const generateNextFrame = () => {
									if (frameIndex >= totalFrames) {
										mediaRecorder.stop();
										audioElement.pause();
										return;
									}
									
									const time = frameIndex / fps;
									this.generateFrame(time, audioAnalysis, stylePreset);
									
									if (onProgress) {
										onProgress(frameIndex + 1, totalFrames);
									}
									
									frameIndex++;
									setTimeout(generateNextFrame, frameInterval);
								};
								
								generateNextFrame();
							});
						} catch (error) {
							console.warn('Failed to add audio to video, generating video-only:', error);
							// Fall back to video-only if audio fails
						}
					}
					
					// Fallback: video-only recording
					const mediaRecorder = new MediaRecorder(videoStream, {
						mimeType: 'video/webm;codecs=vp9'
					});
					
					return new Promise((resolve, reject) => {
						mediaRecorder.ondataavailable = (event) => {
							if (event.data.size > 0) {
								chunks.push(event.data);
							}
						};
						
						mediaRecorder.onstop = () => {
							const blob = new Blob(chunks, { type: 'video/webm' });
							resolve(blob);
						};
						
						mediaRecorder.onerror = reject;
						
						// Start recording
						mediaRecorder.start();
						
						// Generate frames
						let frameIndex = 0;
						const frameInterval = 1000 / fps;
						
						const generateNextFrame = () => {
							if (frameIndex >= totalFrames) {
								mediaRecorder.stop();
								return;
							}
							
							const time = frameIndex / fps;
							this.generateFrame(time, audioAnalysis, stylePreset);
							
							if (onProgress) {
								onProgress(frameIndex + 1, totalFrames);
							}
							
							frameIndex++;
							setTimeout(generateNextFrame, frameInterval);
						};
						
						generateNextFrame();
					});
				}

				async addOverlays(videoBlob: Blob, title: string, guest: string, sponsor: string): Promise<Blob> {
					console.log('Adding overlays in browser...');
					
					// For now, return the original blob
					// In a full implementation, you would use Canvas to add text overlays
					// This is a simplified version
					return videoBlob;
				}

				generateTestAudio(duration: number = 10): Float32Array {
					console.log('Generating test audio...');
					
					const sampleRate = 44100;
					const numSamples = Math.floor(duration * sampleRate);
					const audioData = new Float32Array(numSamples);
					
					// Generate a simple sine wave with varying frequency and amplitude
					for (let i = 0; i < numSamples; i++) {
						const time = i / sampleRate;
						const frequency = 200 + 100 * Math.sin(time * 0.5); // Varying frequency
						const amplitude = 0.3 + 0.2 * Math.sin(time * 2); // Varying amplitude
						const wave = Math.sin(2 * Math.PI * frequency * time);
						
						// Add some variation for more interesting RMS patterns
						const variation = Math.sin(time * 10) * 0.1;
						audioData[i] = (wave + variation) * amplitude;
					}
					
					return audioData;
				}

				createTestAudioAnalysis(duration: number = 10): any {
					console.log('Creating test audio analysis...');
					
					const rmsValues = [];
					const vocalEnergy = [];
					const frequencies = [];
					
					// Generate 100 segments of varying RMS values
					for (let i = 0; i < 100; i++) {
						const time = (i / 100) * duration;
						const baseRms = 0.1 + 0.2 * Math.sin(time * 2) + 0.1 * Math.sin(time * 5);
						const rms = Math.max(0.05, Math.min(0.8, baseRms));
						
						rmsValues.push(rms);
						vocalEnergy.push(Math.min(1, rms * 2));
						frequencies.push(150 + 100 * Math.sin(time * 3));
					}
					
					return {
						duration: duration,
						rms: rmsValues,
						vocalEnergy: vocalEnergy,
						frequencies: frequencies,
						sampleRate: 44100
					};
				}
			}

			// File validation
			fileInput.addEventListener('change', (e) => {
				const file = (e.target as HTMLInputElement).files?.[0];
				if (file) {
					const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
					fileInfo.textContent = `File: ${file.name} (${sizeMB} MB)`;
					
					if (file.size > 250 * 1024 * 1024) {
						fileInfo.style.color = '#ef4444';
						fileInfo.textContent += ' - File too large (max 250MB)';
					} else {
						fileInfo.style.color = '#10b981';
					}
				}
			});

			// Form submission
			form.addEventListener('submit', async (e) => {
				console.log('Form submitted!');
				e.preventDefault();

				const formData = new FormData(form);
				const file = fileInput.files?.[0];

				if (!file) {
					console.log('No file selected');
					alert('Please select an audio file');
					return;
				}

				if (file.size > 250 * 1024 * 1024) {
					console.log('File too large');
					alert('File size exceeds 250MB limit');
					return;
				}

				status.style.display = 'block';
				results.style.display = 'none';
				progressBar.style.width = '0%';
				statusText.textContent = 'Processing audio in browser...';
				statusText.style.color = '#10b981';
				frameCountIndicator.textContent = '';

				// Initialize live preview
				initializeLivePreview();

				try {
					// Create browser video generator
					const videoGenerator = new BrowserVideoGenerator(livePreviewCanvas);
					
					// Analyze audio
					statusText.textContent = 'Analyzing audio...';
					const audioAnalysis = await videoGenerator.analyzeAudio(file);
					console.log('Audio analysis complete:', audioAnalysis);
					
					// Get form data
					const title = (document.getElementById('title') as HTMLInputElement).value || 'Untitled';
					const guest = (document.getElementById('guest') as HTMLInputElement).value || '';
					const sponsor = (document.getElementById('sponsor') as HTMLInputElement).value || '';
					const stylePreset = (document.getElementById('stylePreset') as HTMLSelectElement).value;
					
					// Generate video
					statusText.textContent = 'Generating video frames...';
					stageIndicator.textContent = 'Stage 1: Frame Generation';
					
					const videoBlob = await videoGenerator.generateVideo(audioAnalysis, stylePreset, (frame, total) => {
						const percentage = (frame / total) * 100;
						progressBar.style.width = `${percentage}%`;
						const progressText = progressBar.querySelector('div');
						if (progressText) progressText.textContent = `${Math.round(percentage)}%`;
						frameCountIndicator.textContent = `Frames: ${frame} / ${total}`;
					}, file);
					
					// Add overlays
					statusText.textContent = 'Adding overlays...';
					stageIndicator.textContent = 'Stage 2: Adding Overlays';
					const finalVideoBlob = await videoGenerator.addOverlays(videoBlob, title, guest, sponsor);
					
					// Create download link
					currentVideoUrl = URL.createObjectURL(finalVideoBlob);
					currentVideoPath = 'browser-generated-video.webm';
					
					// Show results
					statusText.textContent = 'Video generation complete!';
					stageIndicator.textContent = 'Complete!';
					statusText.style.color = '#10b981';
					progressBar.style.width = '100%';
					const progressText = progressBar.querySelector('div');
					if (progressText) progressText.textContent = '100%';
					
					showResults({
						duration: audioAnalysis.duration,
						videoPath: currentVideoPath
					});
					
				} catch (error) {
					console.log('Error in form submit handler:', error);
					statusText.textContent = `Error: ${error instanceof Error ? error.message : String(error)}`;
					statusText.style.color = '#ef4444';
					frameCountIndicator.textContent = 'Please check your file and try again';
				}
			});

			function showResults(result: any) {
				const title = (document.getElementById('title') as HTMLInputElement).value || 'Untitled Episode';
				const duration = Math.floor(result.duration || (Math.random() * 60) + 30);
				
				videoInfo.innerHTML = `
					<h4>${title}</h4>
					<p>Duration: ${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}</p>
					<p>Resolution: 1920x1080 (1080p)</p>
					<p>Format: WebM (Browser Generated)</p>
				`;
				
				// Set video source
				if (currentVideoUrl) {
					// Show loading indicator
					videoLoadingIndicator.style.display = 'block';
					videoPlayer.style.display = 'none';
					
					videoPlayer.src = currentVideoUrl;
					videoPlayer.load(); // Load the video
					
					// Add event listener for when video is loaded
					videoPlayer.addEventListener('loadedmetadata', () => {
						console.log('Video loaded successfully');
						// Hide loading indicator and show video
						videoLoadingIndicator.style.display = 'none';
						videoPlayer.style.display = 'block';
					});
					
					videoPlayer.addEventListener('error', (e) => {
						console.error('Error loading video:', e);
						// Hide loading indicator on error
						videoLoadingIndicator.style.display = 'none';
						videoPlayer.style.display = 'block';
					});
				}
				
				results.style.display = 'block';
			}

			// Download button
			downloadBtn.addEventListener('click', () => {
				if (currentVideoUrl) {
					const a = document.createElement('a');
					a.href = currentVideoUrl;
					a.download = 'video-wallpaper.webm';
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
				} else {
					alert('No video available for download.');
				}
			});

			// YouTube upload button
			youtubeBtn.addEventListener('click', async () => {
				alert('YouTube upload requires server-side processing. Please use the server version for YouTube integration.');
			});

			// Test video buttons
			testVideoFrenchNewWave.addEventListener('click', async () => {
				console.log('Test video button clicked');
				
				// Disable button during generation
				testVideoFrenchNewWave.disabled = true;
				testVideoFrenchNewWave.textContent = 'ðŸŽ¬ Generating...';
				
				// Show status
				status.style.display = 'block';
				results.style.display = 'none';
				progressBar.style.width = '0%';
				statusText.textContent = 'Generating test video...';
				statusText.style.color = '#10b981';
				frameCountIndicator.textContent = '';

				// Initialize live preview
				initializeLivePreview();

				try {
					// Clear cache to ensure we use the latest audio file
					clearTestAudioCache();
					
					// Create browser video generator
					const videoGenerator = new BrowserVideoGenerator(livePreviewCanvas);
					
					// Get or create the pre-built test audio file
					statusText.textContent = cachedTestAudioFile ? 'Using cached test audio...' : 'Loading test audio file...';
					const testAudioFile = await getTestAudioFile();
					
					// Analyze the test audio file to create audio context and get proper analysis
					statusText.textContent = 'Analyzing test audio...';
					const audioAnalysis = await videoGenerator.analyzeAudio(testAudioFile);
					console.log('Test audio analysis complete:', audioAnalysis);
					
					// Pre-configured settings
					const title = 'Test Video - Browser Generated';
					const guest = 'Demo Guest';
					const sponsor = 'Demo Sponsor';
					const stylePreset = 'French New Wave'; // Default to French New Wave for testing
					
					// Generate video
					statusText.textContent = 'Generating test video frames...';
					stageIndicator.textContent = 'Stage 1: Frame Generation';
					
					const videoBlob = await videoGenerator.generateVideo(audioAnalysis, stylePreset, (frame, total) => {
						const percentage = (frame / total) * 100;
						progressBar.style.width = `${percentage}%`;
						const progressText = progressBar.querySelector('div');
						if (progressText) progressText.textContent = `${Math.round(percentage)}%`;
						frameCountIndicator.textContent = `Frames: ${frame} / ${total}`;
					}, testAudioFile);
					
					// Add overlays
					statusText.textContent = 'Adding test overlays...';
					stageIndicator.textContent = 'Stage 2: Adding Overlays';
					const finalVideoBlob = await videoGenerator.addOverlays(videoBlob, title, guest, sponsor);
					
					// Create download link
					currentVideoUrl = URL.createObjectURL(finalVideoBlob);
					currentVideoPath = 'test-video-browser-generated.webm';
					
					// Show results
					statusText.textContent = 'Test video generation complete!';
					stageIndicator.textContent = 'Complete!';
					statusText.style.color = '#10b981';
					progressBar.style.width = '100%';
					const progressText = progressBar.querySelector('div');
					if (progressText) progressText.textContent = '100%';
					
					showResults({
						duration: audioAnalysis.duration,
						videoPath: currentVideoPath
					});
					
					console.log('âœ… Test video generated successfully');
					
				} catch (error) {
					console.log('Error generating test video:', error);
					statusText.textContent = `Error: ${error instanceof Error ? error.message : String(error)}`;
					statusText.style.color = '#ef4444';
					frameCountIndicator.textContent = 'Test video generation failed';
				} finally {
					// Re-enable button
					testVideoFrenchNewWave.disabled = false;
					testVideoFrenchNewWave.textContent = 'ðŸŽ¬ French New Wave';
				}
			});

			testVideoRetro.addEventListener('click', async () => {
				console.log('Test video button clicked');
				
				// Disable button during generation
				testVideoRetro.disabled = true;
				testVideoRetro.textContent = 'ðŸŽ¬ Generating...';
				
				// Show status
				status.style.display = 'block';
				results.style.display = 'none';
				progressBar.style.width = '0%';
				statusText.textContent = 'Generating test video...';
				statusText.style.color = '#10b981';
				frameCountIndicator.textContent = '';

				// Initialize live preview
				initializeLivePreview();

				try {
					// Clear cache to ensure we use the latest audio file
					clearTestAudioCache();
					
					// Create browser video generator
					const videoGenerator = new BrowserVideoGenerator(livePreviewCanvas);
					
					// Get or create the pre-built test audio file
					statusText.textContent = cachedTestAudioFile ? 'Using cached test audio...' : 'Loading test audio file...';
					const testAudioFile = await getTestAudioFile();
					
					// Analyze the test audio file to create audio context and get proper analysis
					statusText.textContent = 'Analyzing test audio...';
					const audioAnalysis = await videoGenerator.analyzeAudio(testAudioFile);
					console.log('Test audio analysis complete:', audioAnalysis);
					
					// Pre-configured settings
					const title = 'Test Video - Browser Generated';
					const guest = 'Demo Guest';
					const sponsor = 'Demo Sponsor';
					const stylePreset = "'80s Retro Chromatic"; // Use exact style preset name
					
					// Generate video
					statusText.textContent = 'Generating test video frames...';
					stageIndicator.textContent = 'Stage 1: Frame Generation';
					
					const videoBlob = await videoGenerator.generateVideo(audioAnalysis, stylePreset, (frame, total) => {
						const percentage = (frame / total) * 100;
						progressBar.style.width = `${percentage}%`;
						const progressText = progressBar.querySelector('div');
						if (progressText) progressText.textContent = `${Math.round(percentage)}%`;
						frameCountIndicator.textContent = `Frames: ${frame} / ${total}`;
					}, testAudioFile);
					
					// Add overlays
					statusText.textContent = 'Adding test overlays...';
					stageIndicator.textContent = 'Stage 2: Adding Overlays';
					const finalVideoBlob = await videoGenerator.addOverlays(videoBlob, title, guest, sponsor);
					
					// Create download link
					currentVideoUrl = URL.createObjectURL(finalVideoBlob);
					currentVideoPath = 'test-video-browser-generated.webm';
					
					// Show results
					statusText.textContent = 'Test video generation complete!';
					stageIndicator.textContent = 'Complete!';
					statusText.style.color = '#10b981';
					progressBar.style.width = '100%';
					const progressText = progressBar.querySelector('div');
					if (progressText) progressText.textContent = '100%';
					
					showResults({
						duration: audioAnalysis.duration,
						videoPath: currentVideoPath
					});
					
					console.log('âœ… Test video generated successfully');
					
				} catch (error) {
					console.log('Error generating test video:', error);
					statusText.textContent = `Error: ${error instanceof Error ? error.message : String(error)}`;
					statusText.style.color = '#ef4444';
					frameCountIndicator.textContent = 'Test video generation failed';
				} finally {
					// Re-enable button
					testVideoRetro.disabled = false;
					testVideoRetro.textContent = 'ðŸŽ¬ 80s Retro Chromatic';
				}
			});

			testVideoWineCountry.addEventListener('click', async () => {
				console.log('Test video button clicked');
				
				// Disable button during generation
				testVideoWineCountry.disabled = true;
				testVideoWineCountry.textContent = 'ðŸŽ¬ Generating...';
				
				// Show status
				status.style.display = 'block';
				results.style.display = 'none';
				progressBar.style.width = '0%';
				statusText.textContent = 'Generating test video...';
				statusText.style.color = '#10b981';
				frameCountIndicator.textContent = '';

				// Initialize live preview
				initializeLivePreview();

				try {
					// Clear cache to ensure we use the latest audio file
					clearTestAudioCache();
					
					// Create browser video generator
					const videoGenerator = new BrowserVideoGenerator(livePreviewCanvas);
					
					// Get or create the pre-built test audio file
					statusText.textContent = cachedTestAudioFile ? 'Using cached test audio...' : 'Loading test audio file...';
					const testAudioFile = await getTestAudioFile();
					
					// Analyze the test audio file to create audio context and get proper analysis
					statusText.textContent = 'Analyzing test audio...';
					const audioAnalysis = await videoGenerator.analyzeAudio(testAudioFile);
					console.log('Test audio analysis complete:', audioAnalysis);
					
					// Pre-configured settings
					const title = 'Test Video - Browser Generated';
					const guest = 'Demo Guest';
					const sponsor = 'Demo Sponsor';
					const stylePreset = 'Wine-Country Dreamscape'; // Default to Wine-Country Dreamscape for testing
					
					// Generate video
					statusText.textContent = 'Generating test video frames...';
					stageIndicator.textContent = 'Stage 1: Frame Generation';
					
					const videoBlob = await videoGenerator.generateVideo(audioAnalysis, stylePreset, (frame, total) => {
						const percentage = (frame / total) * 100;
						progressBar.style.width = `${percentage}%`;
						const progressText = progressBar.querySelector('div');
						if (progressText) progressText.textContent = `${Math.round(percentage)}%`;
						frameCountIndicator.textContent = `Frames: ${frame} / ${total}`;
					}, testAudioFile);
					
					// Add overlays
					statusText.textContent = 'Adding test overlays...';
					stageIndicator.textContent = 'Stage 2: Adding Overlays';
					const finalVideoBlob = await videoGenerator.addOverlays(videoBlob, title, guest, sponsor);
					
					// Create download link
					currentVideoUrl = URL.createObjectURL(finalVideoBlob);
					currentVideoPath = 'test-video-browser-generated.webm';
					
					// Show results
					statusText.textContent = 'Test video generation complete!';
					stageIndicator.textContent = 'Complete!';
					statusText.style.color = '#10b981';
					progressBar.style.width = '100%';
					const progressText = progressBar.querySelector('div');
					if (progressText) progressText.textContent = '100%';
					
					showResults({
						duration: audioAnalysis.duration,
						videoPath: currentVideoPath
					});
					
					console.log('âœ… Test video generated successfully');
					
				} catch (error) {
					console.log('Error generating test video:', error);
					statusText.textContent = `Error: ${error instanceof Error ? error.message : String(error)}`;
					statusText.style.color = '#ef4444';
					frameCountIndicator.textContent = 'Test video generation failed';
				} finally {
					// Re-enable button
					testVideoWineCountry.disabled = false;
					testVideoWineCountry.textContent = 'ðŸŽ¬ Wine-Country Dreamscape';
				}
			});

			// Utility function to get the pre-built test audio file
			async function getTestAudioFile(): Promise<File> {
				if (cachedTestAudioFile) {
					return cachedTestAudioFile;
				}

				console.log('Loading pre-built test audio file...');
				
				try {
					// Fetch the test audio file from the public directory
					const response = await fetch('/test-audio-5sec.mp3');
					if (!response.ok) {
						throw new Error(`Failed to load test audio file: ${response.status}`);
					}
					
					const audioBlob = await response.blob();
					cachedTestAudioFile = new File([audioBlob], 'test-audio-5sec.mp3', { type: 'audio/mp3' });
					console.log('Test audio file loaded and cached');
					
					return cachedTestAudioFile;
				} catch (error) {
					console.error('Error loading test audio file:', error);
					throw new Error('Failed to load test audio file. Please try again.');
				}
			}
		</script>
	</body>
</html>
